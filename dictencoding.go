// Code generated by dictencoding.go.tmpl.
// DO NOT EDIT.

package feather

import (
	"fmt"

	"github.com/sglyon/feather/fbs"
)

// Int8Int8DictColumn represents a dict-encoded column with underlying data of type
// Int8 and dict key of type Int8
type Int8Int8DictColumn struct {
	refs *Int8Column
	pool *Int8Column
}

// Value constructs a value of type Int8 from the Int8Int8DictColumn
func (a *Int8Int8DictColumn) Value(i int) (int8, bool) {
	ref, isValid := a.refs.Value(i)
	var out int8
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int8Int8DictColumn) Values() ([]int8, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int8, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int8Int8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int8Int8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int8Int8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int8Int8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int8Int8DictColumn) NullN() int64 { return a.refs.nNull }

// Int8Int16DictColumn represents a dict-encoded column with underlying data of type
// Int8 and dict key of type Int16
type Int8Int16DictColumn struct {
	refs *Int16Column
	pool *Int8Column
}

// Value constructs a value of type Int8 from the Int8Int16DictColumn
func (a *Int8Int16DictColumn) Value(i int) (int8, bool) {
	ref, isValid := a.refs.Value(i)
	var out int8
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int8Int16DictColumn) Values() ([]int8, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int8, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int8Int16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int8Int16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int8Int16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int8Int16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int8Int16DictColumn) NullN() int64 { return a.refs.nNull }

// Int8Int32DictColumn represents a dict-encoded column with underlying data of type
// Int8 and dict key of type Int32
type Int8Int32DictColumn struct {
	refs *Int32Column
	pool *Int8Column
}

// Value constructs a value of type Int8 from the Int8Int32DictColumn
func (a *Int8Int32DictColumn) Value(i int) (int8, bool) {
	ref, isValid := a.refs.Value(i)
	var out int8
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int8Int32DictColumn) Values() ([]int8, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int8, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int8Int32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int8Int32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int8Int32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int8Int32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int8Int32DictColumn) NullN() int64 { return a.refs.nNull }

// Int8Int64DictColumn represents a dict-encoded column with underlying data of type
// Int8 and dict key of type Int64
type Int8Int64DictColumn struct {
	refs *Int64Column
	pool *Int8Column
}

// Value constructs a value of type Int8 from the Int8Int64DictColumn
func (a *Int8Int64DictColumn) Value(i int) (int8, bool) {
	ref, isValid := a.refs.Value(i)
	var out int8
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int8Int64DictColumn) Values() ([]int8, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int8, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int8Int64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int8Int64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int8Int64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int8Int64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int8Int64DictColumn) NullN() int64 { return a.refs.nNull }

// Int8Uint8DictColumn represents a dict-encoded column with underlying data of type
// Int8 and dict key of type Uint8
type Int8Uint8DictColumn struct {
	refs *Uint8Column
	pool *Int8Column
}

// Value constructs a value of type Int8 from the Int8Uint8DictColumn
func (a *Int8Uint8DictColumn) Value(i int) (int8, bool) {
	ref, isValid := a.refs.Value(i)
	var out int8
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int8Uint8DictColumn) Values() ([]int8, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int8, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int8Uint8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int8Uint8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int8Uint8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int8Uint8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int8Uint8DictColumn) NullN() int64 { return a.refs.nNull }

// Int8Uint16DictColumn represents a dict-encoded column with underlying data of type
// Int8 and dict key of type Uint16
type Int8Uint16DictColumn struct {
	refs *Uint16Column
	pool *Int8Column
}

// Value constructs a value of type Int8 from the Int8Uint16DictColumn
func (a *Int8Uint16DictColumn) Value(i int) (int8, bool) {
	ref, isValid := a.refs.Value(i)
	var out int8
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int8Uint16DictColumn) Values() ([]int8, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int8, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int8Uint16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int8Uint16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int8Uint16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int8Uint16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int8Uint16DictColumn) NullN() int64 { return a.refs.nNull }

// Int8Uint32DictColumn represents a dict-encoded column with underlying data of type
// Int8 and dict key of type Uint32
type Int8Uint32DictColumn struct {
	refs *Uint32Column
	pool *Int8Column
}

// Value constructs a value of type Int8 from the Int8Uint32DictColumn
func (a *Int8Uint32DictColumn) Value(i int) (int8, bool) {
	ref, isValid := a.refs.Value(i)
	var out int8
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int8Uint32DictColumn) Values() ([]int8, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int8, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int8Uint32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int8Uint32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int8Uint32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int8Uint32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int8Uint32DictColumn) NullN() int64 { return a.refs.nNull }

// Int8Uint64DictColumn represents a dict-encoded column with underlying data of type
// Int8 and dict key of type Uint64
type Int8Uint64DictColumn struct {
	refs *Uint64Column
	pool *Int8Column
}

// Value constructs a value of type Int8 from the Int8Uint64DictColumn
func (a *Int8Uint64DictColumn) Value(i int) (int8, bool) {
	ref, isValid := a.refs.Value(i)
	var out int8
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int8Uint64DictColumn) Values() ([]int8, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int8, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int8Uint64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int8Uint64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int8Uint64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int8Uint64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int8Uint64DictColumn) NullN() int64 { return a.refs.nNull }

// Int16Int8DictColumn represents a dict-encoded column with underlying data of type
// Int16 and dict key of type Int8
type Int16Int8DictColumn struct {
	refs *Int8Column
	pool *Int16Column
}

// Value constructs a value of type Int16 from the Int16Int8DictColumn
func (a *Int16Int8DictColumn) Value(i int) (int16, bool) {
	ref, isValid := a.refs.Value(i)
	var out int16
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int16Int8DictColumn) Values() ([]int16, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int16, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int16Int8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int16Int8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int16Int8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int16Int8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int16Int8DictColumn) NullN() int64 { return a.refs.nNull }

// Int16Int16DictColumn represents a dict-encoded column with underlying data of type
// Int16 and dict key of type Int16
type Int16Int16DictColumn struct {
	refs *Int16Column
	pool *Int16Column
}

// Value constructs a value of type Int16 from the Int16Int16DictColumn
func (a *Int16Int16DictColumn) Value(i int) (int16, bool) {
	ref, isValid := a.refs.Value(i)
	var out int16
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int16Int16DictColumn) Values() ([]int16, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int16, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int16Int16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int16Int16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int16Int16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int16Int16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int16Int16DictColumn) NullN() int64 { return a.refs.nNull }

// Int16Int32DictColumn represents a dict-encoded column with underlying data of type
// Int16 and dict key of type Int32
type Int16Int32DictColumn struct {
	refs *Int32Column
	pool *Int16Column
}

// Value constructs a value of type Int16 from the Int16Int32DictColumn
func (a *Int16Int32DictColumn) Value(i int) (int16, bool) {
	ref, isValid := a.refs.Value(i)
	var out int16
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int16Int32DictColumn) Values() ([]int16, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int16, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int16Int32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int16Int32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int16Int32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int16Int32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int16Int32DictColumn) NullN() int64 { return a.refs.nNull }

// Int16Int64DictColumn represents a dict-encoded column with underlying data of type
// Int16 and dict key of type Int64
type Int16Int64DictColumn struct {
	refs *Int64Column
	pool *Int16Column
}

// Value constructs a value of type Int16 from the Int16Int64DictColumn
func (a *Int16Int64DictColumn) Value(i int) (int16, bool) {
	ref, isValid := a.refs.Value(i)
	var out int16
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int16Int64DictColumn) Values() ([]int16, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int16, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int16Int64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int16Int64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int16Int64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int16Int64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int16Int64DictColumn) NullN() int64 { return a.refs.nNull }

// Int16Uint8DictColumn represents a dict-encoded column with underlying data of type
// Int16 and dict key of type Uint8
type Int16Uint8DictColumn struct {
	refs *Uint8Column
	pool *Int16Column
}

// Value constructs a value of type Int16 from the Int16Uint8DictColumn
func (a *Int16Uint8DictColumn) Value(i int) (int16, bool) {
	ref, isValid := a.refs.Value(i)
	var out int16
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int16Uint8DictColumn) Values() ([]int16, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int16, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int16Uint8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int16Uint8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int16Uint8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int16Uint8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int16Uint8DictColumn) NullN() int64 { return a.refs.nNull }

// Int16Uint16DictColumn represents a dict-encoded column with underlying data of type
// Int16 and dict key of type Uint16
type Int16Uint16DictColumn struct {
	refs *Uint16Column
	pool *Int16Column
}

// Value constructs a value of type Int16 from the Int16Uint16DictColumn
func (a *Int16Uint16DictColumn) Value(i int) (int16, bool) {
	ref, isValid := a.refs.Value(i)
	var out int16
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int16Uint16DictColumn) Values() ([]int16, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int16, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int16Uint16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int16Uint16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int16Uint16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int16Uint16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int16Uint16DictColumn) NullN() int64 { return a.refs.nNull }

// Int16Uint32DictColumn represents a dict-encoded column with underlying data of type
// Int16 and dict key of type Uint32
type Int16Uint32DictColumn struct {
	refs *Uint32Column
	pool *Int16Column
}

// Value constructs a value of type Int16 from the Int16Uint32DictColumn
func (a *Int16Uint32DictColumn) Value(i int) (int16, bool) {
	ref, isValid := a.refs.Value(i)
	var out int16
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int16Uint32DictColumn) Values() ([]int16, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int16, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int16Uint32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int16Uint32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int16Uint32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int16Uint32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int16Uint32DictColumn) NullN() int64 { return a.refs.nNull }

// Int16Uint64DictColumn represents a dict-encoded column with underlying data of type
// Int16 and dict key of type Uint64
type Int16Uint64DictColumn struct {
	refs *Uint64Column
	pool *Int16Column
}

// Value constructs a value of type Int16 from the Int16Uint64DictColumn
func (a *Int16Uint64DictColumn) Value(i int) (int16, bool) {
	ref, isValid := a.refs.Value(i)
	var out int16
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int16Uint64DictColumn) Values() ([]int16, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int16, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int16Uint64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int16Uint64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int16Uint64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int16Uint64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int16Uint64DictColumn) NullN() int64 { return a.refs.nNull }

// Int32Int8DictColumn represents a dict-encoded column with underlying data of type
// Int32 and dict key of type Int8
type Int32Int8DictColumn struct {
	refs *Int8Column
	pool *Int32Column
}

// Value constructs a value of type Int32 from the Int32Int8DictColumn
func (a *Int32Int8DictColumn) Value(i int) (int32, bool) {
	ref, isValid := a.refs.Value(i)
	var out int32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int32Int8DictColumn) Values() ([]int32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int32Int8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int32Int8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int32Int8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int32Int8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int32Int8DictColumn) NullN() int64 { return a.refs.nNull }

// Int32Int16DictColumn represents a dict-encoded column with underlying data of type
// Int32 and dict key of type Int16
type Int32Int16DictColumn struct {
	refs *Int16Column
	pool *Int32Column
}

// Value constructs a value of type Int32 from the Int32Int16DictColumn
func (a *Int32Int16DictColumn) Value(i int) (int32, bool) {
	ref, isValid := a.refs.Value(i)
	var out int32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int32Int16DictColumn) Values() ([]int32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int32Int16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int32Int16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int32Int16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int32Int16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int32Int16DictColumn) NullN() int64 { return a.refs.nNull }

// Int32Int32DictColumn represents a dict-encoded column with underlying data of type
// Int32 and dict key of type Int32
type Int32Int32DictColumn struct {
	refs *Int32Column
	pool *Int32Column
}

// Value constructs a value of type Int32 from the Int32Int32DictColumn
func (a *Int32Int32DictColumn) Value(i int) (int32, bool) {
	ref, isValid := a.refs.Value(i)
	var out int32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int32Int32DictColumn) Values() ([]int32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int32Int32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int32Int32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int32Int32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int32Int32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int32Int32DictColumn) NullN() int64 { return a.refs.nNull }

// Int32Int64DictColumn represents a dict-encoded column with underlying data of type
// Int32 and dict key of type Int64
type Int32Int64DictColumn struct {
	refs *Int64Column
	pool *Int32Column
}

// Value constructs a value of type Int32 from the Int32Int64DictColumn
func (a *Int32Int64DictColumn) Value(i int) (int32, bool) {
	ref, isValid := a.refs.Value(i)
	var out int32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int32Int64DictColumn) Values() ([]int32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int32Int64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int32Int64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int32Int64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int32Int64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int32Int64DictColumn) NullN() int64 { return a.refs.nNull }

// Int32Uint8DictColumn represents a dict-encoded column with underlying data of type
// Int32 and dict key of type Uint8
type Int32Uint8DictColumn struct {
	refs *Uint8Column
	pool *Int32Column
}

// Value constructs a value of type Int32 from the Int32Uint8DictColumn
func (a *Int32Uint8DictColumn) Value(i int) (int32, bool) {
	ref, isValid := a.refs.Value(i)
	var out int32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int32Uint8DictColumn) Values() ([]int32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int32Uint8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int32Uint8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int32Uint8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int32Uint8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int32Uint8DictColumn) NullN() int64 { return a.refs.nNull }

// Int32Uint16DictColumn represents a dict-encoded column with underlying data of type
// Int32 and dict key of type Uint16
type Int32Uint16DictColumn struct {
	refs *Uint16Column
	pool *Int32Column
}

// Value constructs a value of type Int32 from the Int32Uint16DictColumn
func (a *Int32Uint16DictColumn) Value(i int) (int32, bool) {
	ref, isValid := a.refs.Value(i)
	var out int32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int32Uint16DictColumn) Values() ([]int32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int32Uint16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int32Uint16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int32Uint16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int32Uint16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int32Uint16DictColumn) NullN() int64 { return a.refs.nNull }

// Int32Uint32DictColumn represents a dict-encoded column with underlying data of type
// Int32 and dict key of type Uint32
type Int32Uint32DictColumn struct {
	refs *Uint32Column
	pool *Int32Column
}

// Value constructs a value of type Int32 from the Int32Uint32DictColumn
func (a *Int32Uint32DictColumn) Value(i int) (int32, bool) {
	ref, isValid := a.refs.Value(i)
	var out int32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int32Uint32DictColumn) Values() ([]int32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int32Uint32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int32Uint32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int32Uint32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int32Uint32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int32Uint32DictColumn) NullN() int64 { return a.refs.nNull }

// Int32Uint64DictColumn represents a dict-encoded column with underlying data of type
// Int32 and dict key of type Uint64
type Int32Uint64DictColumn struct {
	refs *Uint64Column
	pool *Int32Column
}

// Value constructs a value of type Int32 from the Int32Uint64DictColumn
func (a *Int32Uint64DictColumn) Value(i int) (int32, bool) {
	ref, isValid := a.refs.Value(i)
	var out int32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int32Uint64DictColumn) Values() ([]int32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int32Uint64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int32Uint64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int32Uint64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int32Uint64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int32Uint64DictColumn) NullN() int64 { return a.refs.nNull }

// Int64Int8DictColumn represents a dict-encoded column with underlying data of type
// Int64 and dict key of type Int8
type Int64Int8DictColumn struct {
	refs *Int8Column
	pool *Int64Column
}

// Value constructs a value of type Int64 from the Int64Int8DictColumn
func (a *Int64Int8DictColumn) Value(i int) (int64, bool) {
	ref, isValid := a.refs.Value(i)
	var out int64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int64Int8DictColumn) Values() ([]int64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int64Int8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int64Int8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int64Int8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int64Int8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int64Int8DictColumn) NullN() int64 { return a.refs.nNull }

// Int64Int16DictColumn represents a dict-encoded column with underlying data of type
// Int64 and dict key of type Int16
type Int64Int16DictColumn struct {
	refs *Int16Column
	pool *Int64Column
}

// Value constructs a value of type Int64 from the Int64Int16DictColumn
func (a *Int64Int16DictColumn) Value(i int) (int64, bool) {
	ref, isValid := a.refs.Value(i)
	var out int64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int64Int16DictColumn) Values() ([]int64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int64Int16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int64Int16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int64Int16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int64Int16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int64Int16DictColumn) NullN() int64 { return a.refs.nNull }

// Int64Int32DictColumn represents a dict-encoded column with underlying data of type
// Int64 and dict key of type Int32
type Int64Int32DictColumn struct {
	refs *Int32Column
	pool *Int64Column
}

// Value constructs a value of type Int64 from the Int64Int32DictColumn
func (a *Int64Int32DictColumn) Value(i int) (int64, bool) {
	ref, isValid := a.refs.Value(i)
	var out int64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int64Int32DictColumn) Values() ([]int64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int64Int32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int64Int32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int64Int32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int64Int32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int64Int32DictColumn) NullN() int64 { return a.refs.nNull }

// Int64Int64DictColumn represents a dict-encoded column with underlying data of type
// Int64 and dict key of type Int64
type Int64Int64DictColumn struct {
	refs *Int64Column
	pool *Int64Column
}

// Value constructs a value of type Int64 from the Int64Int64DictColumn
func (a *Int64Int64DictColumn) Value(i int) (int64, bool) {
	ref, isValid := a.refs.Value(i)
	var out int64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int64Int64DictColumn) Values() ([]int64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int64Int64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int64Int64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int64Int64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int64Int64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int64Int64DictColumn) NullN() int64 { return a.refs.nNull }

// Int64Uint8DictColumn represents a dict-encoded column with underlying data of type
// Int64 and dict key of type Uint8
type Int64Uint8DictColumn struct {
	refs *Uint8Column
	pool *Int64Column
}

// Value constructs a value of type Int64 from the Int64Uint8DictColumn
func (a *Int64Uint8DictColumn) Value(i int) (int64, bool) {
	ref, isValid := a.refs.Value(i)
	var out int64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int64Uint8DictColumn) Values() ([]int64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int64Uint8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int64Uint8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int64Uint8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int64Uint8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int64Uint8DictColumn) NullN() int64 { return a.refs.nNull }

// Int64Uint16DictColumn represents a dict-encoded column with underlying data of type
// Int64 and dict key of type Uint16
type Int64Uint16DictColumn struct {
	refs *Uint16Column
	pool *Int64Column
}

// Value constructs a value of type Int64 from the Int64Uint16DictColumn
func (a *Int64Uint16DictColumn) Value(i int) (int64, bool) {
	ref, isValid := a.refs.Value(i)
	var out int64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int64Uint16DictColumn) Values() ([]int64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int64Uint16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int64Uint16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int64Uint16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int64Uint16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int64Uint16DictColumn) NullN() int64 { return a.refs.nNull }

// Int64Uint32DictColumn represents a dict-encoded column with underlying data of type
// Int64 and dict key of type Uint32
type Int64Uint32DictColumn struct {
	refs *Uint32Column
	pool *Int64Column
}

// Value constructs a value of type Int64 from the Int64Uint32DictColumn
func (a *Int64Uint32DictColumn) Value(i int) (int64, bool) {
	ref, isValid := a.refs.Value(i)
	var out int64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int64Uint32DictColumn) Values() ([]int64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int64Uint32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int64Uint32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int64Uint32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int64Uint32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int64Uint32DictColumn) NullN() int64 { return a.refs.nNull }

// Int64Uint64DictColumn represents a dict-encoded column with underlying data of type
// Int64 and dict key of type Uint64
type Int64Uint64DictColumn struct {
	refs *Uint64Column
	pool *Int64Column
}

// Value constructs a value of type Int64 from the Int64Uint64DictColumn
func (a *Int64Uint64DictColumn) Value(i int) (int64, bool) {
	ref, isValid := a.refs.Value(i)
	var out int64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Int64Uint64DictColumn) Values() ([]int64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]int64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Int64Uint64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Int64Uint64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Int64Uint64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Int64Uint64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Int64Uint64DictColumn) NullN() int64 { return a.refs.nNull }

// Uint8Int8DictColumn represents a dict-encoded column with underlying data of type
// Uint8 and dict key of type Int8
type Uint8Int8DictColumn struct {
	refs *Int8Column
	pool *Uint8Column
}

// Value constructs a value of type Uint8 from the Uint8Int8DictColumn
func (a *Uint8Int8DictColumn) Value(i int) (uint8, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint8
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint8Int8DictColumn) Values() ([]uint8, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint8, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint8Int8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint8Int8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint8Int8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint8Int8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint8Int8DictColumn) NullN() int64 { return a.refs.nNull }

// Uint8Int16DictColumn represents a dict-encoded column with underlying data of type
// Uint8 and dict key of type Int16
type Uint8Int16DictColumn struct {
	refs *Int16Column
	pool *Uint8Column
}

// Value constructs a value of type Uint8 from the Uint8Int16DictColumn
func (a *Uint8Int16DictColumn) Value(i int) (uint8, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint8
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint8Int16DictColumn) Values() ([]uint8, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint8, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint8Int16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint8Int16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint8Int16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint8Int16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint8Int16DictColumn) NullN() int64 { return a.refs.nNull }

// Uint8Int32DictColumn represents a dict-encoded column with underlying data of type
// Uint8 and dict key of type Int32
type Uint8Int32DictColumn struct {
	refs *Int32Column
	pool *Uint8Column
}

// Value constructs a value of type Uint8 from the Uint8Int32DictColumn
func (a *Uint8Int32DictColumn) Value(i int) (uint8, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint8
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint8Int32DictColumn) Values() ([]uint8, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint8, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint8Int32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint8Int32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint8Int32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint8Int32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint8Int32DictColumn) NullN() int64 { return a.refs.nNull }

// Uint8Int64DictColumn represents a dict-encoded column with underlying data of type
// Uint8 and dict key of type Int64
type Uint8Int64DictColumn struct {
	refs *Int64Column
	pool *Uint8Column
}

// Value constructs a value of type Uint8 from the Uint8Int64DictColumn
func (a *Uint8Int64DictColumn) Value(i int) (uint8, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint8
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint8Int64DictColumn) Values() ([]uint8, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint8, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint8Int64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint8Int64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint8Int64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint8Int64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint8Int64DictColumn) NullN() int64 { return a.refs.nNull }

// Uint8Uint8DictColumn represents a dict-encoded column with underlying data of type
// Uint8 and dict key of type Uint8
type Uint8Uint8DictColumn struct {
	refs *Uint8Column
	pool *Uint8Column
}

// Value constructs a value of type Uint8 from the Uint8Uint8DictColumn
func (a *Uint8Uint8DictColumn) Value(i int) (uint8, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint8
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint8Uint8DictColumn) Values() ([]uint8, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint8, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint8Uint8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint8Uint8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint8Uint8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint8Uint8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint8Uint8DictColumn) NullN() int64 { return a.refs.nNull }

// Uint8Uint16DictColumn represents a dict-encoded column with underlying data of type
// Uint8 and dict key of type Uint16
type Uint8Uint16DictColumn struct {
	refs *Uint16Column
	pool *Uint8Column
}

// Value constructs a value of type Uint8 from the Uint8Uint16DictColumn
func (a *Uint8Uint16DictColumn) Value(i int) (uint8, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint8
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint8Uint16DictColumn) Values() ([]uint8, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint8, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint8Uint16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint8Uint16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint8Uint16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint8Uint16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint8Uint16DictColumn) NullN() int64 { return a.refs.nNull }

// Uint8Uint32DictColumn represents a dict-encoded column with underlying data of type
// Uint8 and dict key of type Uint32
type Uint8Uint32DictColumn struct {
	refs *Uint32Column
	pool *Uint8Column
}

// Value constructs a value of type Uint8 from the Uint8Uint32DictColumn
func (a *Uint8Uint32DictColumn) Value(i int) (uint8, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint8
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint8Uint32DictColumn) Values() ([]uint8, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint8, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint8Uint32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint8Uint32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint8Uint32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint8Uint32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint8Uint32DictColumn) NullN() int64 { return a.refs.nNull }

// Uint8Uint64DictColumn represents a dict-encoded column with underlying data of type
// Uint8 and dict key of type Uint64
type Uint8Uint64DictColumn struct {
	refs *Uint64Column
	pool *Uint8Column
}

// Value constructs a value of type Uint8 from the Uint8Uint64DictColumn
func (a *Uint8Uint64DictColumn) Value(i int) (uint8, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint8
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint8Uint64DictColumn) Values() ([]uint8, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint8, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint8Uint64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint8Uint64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint8Uint64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint8Uint64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint8Uint64DictColumn) NullN() int64 { return a.refs.nNull }

// Uint16Int8DictColumn represents a dict-encoded column with underlying data of type
// Uint16 and dict key of type Int8
type Uint16Int8DictColumn struct {
	refs *Int8Column
	pool *Uint16Column
}

// Value constructs a value of type Uint16 from the Uint16Int8DictColumn
func (a *Uint16Int8DictColumn) Value(i int) (uint16, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint16
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint16Int8DictColumn) Values() ([]uint16, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint16, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint16Int8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint16Int8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint16Int8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint16Int8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint16Int8DictColumn) NullN() int64 { return a.refs.nNull }

// Uint16Int16DictColumn represents a dict-encoded column with underlying data of type
// Uint16 and dict key of type Int16
type Uint16Int16DictColumn struct {
	refs *Int16Column
	pool *Uint16Column
}

// Value constructs a value of type Uint16 from the Uint16Int16DictColumn
func (a *Uint16Int16DictColumn) Value(i int) (uint16, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint16
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint16Int16DictColumn) Values() ([]uint16, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint16, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint16Int16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint16Int16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint16Int16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint16Int16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint16Int16DictColumn) NullN() int64 { return a.refs.nNull }

// Uint16Int32DictColumn represents a dict-encoded column with underlying data of type
// Uint16 and dict key of type Int32
type Uint16Int32DictColumn struct {
	refs *Int32Column
	pool *Uint16Column
}

// Value constructs a value of type Uint16 from the Uint16Int32DictColumn
func (a *Uint16Int32DictColumn) Value(i int) (uint16, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint16
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint16Int32DictColumn) Values() ([]uint16, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint16, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint16Int32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint16Int32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint16Int32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint16Int32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint16Int32DictColumn) NullN() int64 { return a.refs.nNull }

// Uint16Int64DictColumn represents a dict-encoded column with underlying data of type
// Uint16 and dict key of type Int64
type Uint16Int64DictColumn struct {
	refs *Int64Column
	pool *Uint16Column
}

// Value constructs a value of type Uint16 from the Uint16Int64DictColumn
func (a *Uint16Int64DictColumn) Value(i int) (uint16, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint16
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint16Int64DictColumn) Values() ([]uint16, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint16, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint16Int64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint16Int64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint16Int64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint16Int64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint16Int64DictColumn) NullN() int64 { return a.refs.nNull }

// Uint16Uint8DictColumn represents a dict-encoded column with underlying data of type
// Uint16 and dict key of type Uint8
type Uint16Uint8DictColumn struct {
	refs *Uint8Column
	pool *Uint16Column
}

// Value constructs a value of type Uint16 from the Uint16Uint8DictColumn
func (a *Uint16Uint8DictColumn) Value(i int) (uint16, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint16
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint16Uint8DictColumn) Values() ([]uint16, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint16, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint16Uint8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint16Uint8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint16Uint8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint16Uint8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint16Uint8DictColumn) NullN() int64 { return a.refs.nNull }

// Uint16Uint16DictColumn represents a dict-encoded column with underlying data of type
// Uint16 and dict key of type Uint16
type Uint16Uint16DictColumn struct {
	refs *Uint16Column
	pool *Uint16Column
}

// Value constructs a value of type Uint16 from the Uint16Uint16DictColumn
func (a *Uint16Uint16DictColumn) Value(i int) (uint16, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint16
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint16Uint16DictColumn) Values() ([]uint16, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint16, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint16Uint16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint16Uint16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint16Uint16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint16Uint16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint16Uint16DictColumn) NullN() int64 { return a.refs.nNull }

// Uint16Uint32DictColumn represents a dict-encoded column with underlying data of type
// Uint16 and dict key of type Uint32
type Uint16Uint32DictColumn struct {
	refs *Uint32Column
	pool *Uint16Column
}

// Value constructs a value of type Uint16 from the Uint16Uint32DictColumn
func (a *Uint16Uint32DictColumn) Value(i int) (uint16, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint16
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint16Uint32DictColumn) Values() ([]uint16, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint16, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint16Uint32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint16Uint32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint16Uint32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint16Uint32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint16Uint32DictColumn) NullN() int64 { return a.refs.nNull }

// Uint16Uint64DictColumn represents a dict-encoded column with underlying data of type
// Uint16 and dict key of type Uint64
type Uint16Uint64DictColumn struct {
	refs *Uint64Column
	pool *Uint16Column
}

// Value constructs a value of type Uint16 from the Uint16Uint64DictColumn
func (a *Uint16Uint64DictColumn) Value(i int) (uint16, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint16
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint16Uint64DictColumn) Values() ([]uint16, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint16, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint16Uint64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint16Uint64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint16Uint64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint16Uint64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint16Uint64DictColumn) NullN() int64 { return a.refs.nNull }

// Uint32Int8DictColumn represents a dict-encoded column with underlying data of type
// Uint32 and dict key of type Int8
type Uint32Int8DictColumn struct {
	refs *Int8Column
	pool *Uint32Column
}

// Value constructs a value of type Uint32 from the Uint32Int8DictColumn
func (a *Uint32Int8DictColumn) Value(i int) (uint32, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint32Int8DictColumn) Values() ([]uint32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint32Int8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint32Int8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint32Int8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint32Int8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint32Int8DictColumn) NullN() int64 { return a.refs.nNull }

// Uint32Int16DictColumn represents a dict-encoded column with underlying data of type
// Uint32 and dict key of type Int16
type Uint32Int16DictColumn struct {
	refs *Int16Column
	pool *Uint32Column
}

// Value constructs a value of type Uint32 from the Uint32Int16DictColumn
func (a *Uint32Int16DictColumn) Value(i int) (uint32, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint32Int16DictColumn) Values() ([]uint32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint32Int16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint32Int16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint32Int16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint32Int16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint32Int16DictColumn) NullN() int64 { return a.refs.nNull }

// Uint32Int32DictColumn represents a dict-encoded column with underlying data of type
// Uint32 and dict key of type Int32
type Uint32Int32DictColumn struct {
	refs *Int32Column
	pool *Uint32Column
}

// Value constructs a value of type Uint32 from the Uint32Int32DictColumn
func (a *Uint32Int32DictColumn) Value(i int) (uint32, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint32Int32DictColumn) Values() ([]uint32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint32Int32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint32Int32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint32Int32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint32Int32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint32Int32DictColumn) NullN() int64 { return a.refs.nNull }

// Uint32Int64DictColumn represents a dict-encoded column with underlying data of type
// Uint32 and dict key of type Int64
type Uint32Int64DictColumn struct {
	refs *Int64Column
	pool *Uint32Column
}

// Value constructs a value of type Uint32 from the Uint32Int64DictColumn
func (a *Uint32Int64DictColumn) Value(i int) (uint32, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint32Int64DictColumn) Values() ([]uint32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint32Int64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint32Int64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint32Int64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint32Int64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint32Int64DictColumn) NullN() int64 { return a.refs.nNull }

// Uint32Uint8DictColumn represents a dict-encoded column with underlying data of type
// Uint32 and dict key of type Uint8
type Uint32Uint8DictColumn struct {
	refs *Uint8Column
	pool *Uint32Column
}

// Value constructs a value of type Uint32 from the Uint32Uint8DictColumn
func (a *Uint32Uint8DictColumn) Value(i int) (uint32, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint32Uint8DictColumn) Values() ([]uint32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint32Uint8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint32Uint8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint32Uint8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint32Uint8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint32Uint8DictColumn) NullN() int64 { return a.refs.nNull }

// Uint32Uint16DictColumn represents a dict-encoded column with underlying data of type
// Uint32 and dict key of type Uint16
type Uint32Uint16DictColumn struct {
	refs *Uint16Column
	pool *Uint32Column
}

// Value constructs a value of type Uint32 from the Uint32Uint16DictColumn
func (a *Uint32Uint16DictColumn) Value(i int) (uint32, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint32Uint16DictColumn) Values() ([]uint32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint32Uint16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint32Uint16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint32Uint16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint32Uint16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint32Uint16DictColumn) NullN() int64 { return a.refs.nNull }

// Uint32Uint32DictColumn represents a dict-encoded column with underlying data of type
// Uint32 and dict key of type Uint32
type Uint32Uint32DictColumn struct {
	refs *Uint32Column
	pool *Uint32Column
}

// Value constructs a value of type Uint32 from the Uint32Uint32DictColumn
func (a *Uint32Uint32DictColumn) Value(i int) (uint32, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint32Uint32DictColumn) Values() ([]uint32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint32Uint32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint32Uint32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint32Uint32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint32Uint32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint32Uint32DictColumn) NullN() int64 { return a.refs.nNull }

// Uint32Uint64DictColumn represents a dict-encoded column with underlying data of type
// Uint32 and dict key of type Uint64
type Uint32Uint64DictColumn struct {
	refs *Uint64Column
	pool *Uint32Column
}

// Value constructs a value of type Uint32 from the Uint32Uint64DictColumn
func (a *Uint32Uint64DictColumn) Value(i int) (uint32, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint32Uint64DictColumn) Values() ([]uint32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint32Uint64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint32Uint64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint32Uint64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint32Uint64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint32Uint64DictColumn) NullN() int64 { return a.refs.nNull }

// Uint64Int8DictColumn represents a dict-encoded column with underlying data of type
// Uint64 and dict key of type Int8
type Uint64Int8DictColumn struct {
	refs *Int8Column
	pool *Uint64Column
}

// Value constructs a value of type Uint64 from the Uint64Int8DictColumn
func (a *Uint64Int8DictColumn) Value(i int) (uint64, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint64Int8DictColumn) Values() ([]uint64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint64Int8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint64Int8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint64Int8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint64Int8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint64Int8DictColumn) NullN() int64 { return a.refs.nNull }

// Uint64Int16DictColumn represents a dict-encoded column with underlying data of type
// Uint64 and dict key of type Int16
type Uint64Int16DictColumn struct {
	refs *Int16Column
	pool *Uint64Column
}

// Value constructs a value of type Uint64 from the Uint64Int16DictColumn
func (a *Uint64Int16DictColumn) Value(i int) (uint64, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint64Int16DictColumn) Values() ([]uint64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint64Int16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint64Int16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint64Int16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint64Int16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint64Int16DictColumn) NullN() int64 { return a.refs.nNull }

// Uint64Int32DictColumn represents a dict-encoded column with underlying data of type
// Uint64 and dict key of type Int32
type Uint64Int32DictColumn struct {
	refs *Int32Column
	pool *Uint64Column
}

// Value constructs a value of type Uint64 from the Uint64Int32DictColumn
func (a *Uint64Int32DictColumn) Value(i int) (uint64, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint64Int32DictColumn) Values() ([]uint64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint64Int32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint64Int32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint64Int32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint64Int32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint64Int32DictColumn) NullN() int64 { return a.refs.nNull }

// Uint64Int64DictColumn represents a dict-encoded column with underlying data of type
// Uint64 and dict key of type Int64
type Uint64Int64DictColumn struct {
	refs *Int64Column
	pool *Uint64Column
}

// Value constructs a value of type Uint64 from the Uint64Int64DictColumn
func (a *Uint64Int64DictColumn) Value(i int) (uint64, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint64Int64DictColumn) Values() ([]uint64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint64Int64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint64Int64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint64Int64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint64Int64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint64Int64DictColumn) NullN() int64 { return a.refs.nNull }

// Uint64Uint8DictColumn represents a dict-encoded column with underlying data of type
// Uint64 and dict key of type Uint8
type Uint64Uint8DictColumn struct {
	refs *Uint8Column
	pool *Uint64Column
}

// Value constructs a value of type Uint64 from the Uint64Uint8DictColumn
func (a *Uint64Uint8DictColumn) Value(i int) (uint64, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint64Uint8DictColumn) Values() ([]uint64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint64Uint8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint64Uint8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint64Uint8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint64Uint8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint64Uint8DictColumn) NullN() int64 { return a.refs.nNull }

// Uint64Uint16DictColumn represents a dict-encoded column with underlying data of type
// Uint64 and dict key of type Uint16
type Uint64Uint16DictColumn struct {
	refs *Uint16Column
	pool *Uint64Column
}

// Value constructs a value of type Uint64 from the Uint64Uint16DictColumn
func (a *Uint64Uint16DictColumn) Value(i int) (uint64, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint64Uint16DictColumn) Values() ([]uint64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint64Uint16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint64Uint16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint64Uint16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint64Uint16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint64Uint16DictColumn) NullN() int64 { return a.refs.nNull }

// Uint64Uint32DictColumn represents a dict-encoded column with underlying data of type
// Uint64 and dict key of type Uint32
type Uint64Uint32DictColumn struct {
	refs *Uint32Column
	pool *Uint64Column
}

// Value constructs a value of type Uint64 from the Uint64Uint32DictColumn
func (a *Uint64Uint32DictColumn) Value(i int) (uint64, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint64Uint32DictColumn) Values() ([]uint64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint64Uint32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint64Uint32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint64Uint32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint64Uint32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint64Uint32DictColumn) NullN() int64 { return a.refs.nNull }

// Uint64Uint64DictColumn represents a dict-encoded column with underlying data of type
// Uint64 and dict key of type Uint64
type Uint64Uint64DictColumn struct {
	refs *Uint64Column
	pool *Uint64Column
}

// Value constructs a value of type Uint64 from the Uint64Uint64DictColumn
func (a *Uint64Uint64DictColumn) Value(i int) (uint64, bool) {
	ref, isValid := a.refs.Value(i)
	var out uint64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Uint64Uint64DictColumn) Values() ([]uint64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]uint64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Uint64Uint64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Uint64Uint64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Uint64Uint64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Uint64Uint64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Uint64Uint64DictColumn) NullN() int64 { return a.refs.nNull }

// Float32Int8DictColumn represents a dict-encoded column with underlying data of type
// Float32 and dict key of type Int8
type Float32Int8DictColumn struct {
	refs *Int8Column
	pool *Float32Column
}

// Value constructs a value of type Float32 from the Float32Int8DictColumn
func (a *Float32Int8DictColumn) Value(i int) (float32, bool) {
	ref, isValid := a.refs.Value(i)
	var out float32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float32Int8DictColumn) Values() ([]float32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]float32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Float32Int8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Float32Int8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float32Int8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float32Int8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Float32Int8DictColumn) NullN() int64 { return a.refs.nNull }

// Float32Int16DictColumn represents a dict-encoded column with underlying data of type
// Float32 and dict key of type Int16
type Float32Int16DictColumn struct {
	refs *Int16Column
	pool *Float32Column
}

// Value constructs a value of type Float32 from the Float32Int16DictColumn
func (a *Float32Int16DictColumn) Value(i int) (float32, bool) {
	ref, isValid := a.refs.Value(i)
	var out float32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float32Int16DictColumn) Values() ([]float32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]float32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Float32Int16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Float32Int16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float32Int16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float32Int16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Float32Int16DictColumn) NullN() int64 { return a.refs.nNull }

// Float32Int32DictColumn represents a dict-encoded column with underlying data of type
// Float32 and dict key of type Int32
type Float32Int32DictColumn struct {
	refs *Int32Column
	pool *Float32Column
}

// Value constructs a value of type Float32 from the Float32Int32DictColumn
func (a *Float32Int32DictColumn) Value(i int) (float32, bool) {
	ref, isValid := a.refs.Value(i)
	var out float32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float32Int32DictColumn) Values() ([]float32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]float32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Float32Int32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Float32Int32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float32Int32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float32Int32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Float32Int32DictColumn) NullN() int64 { return a.refs.nNull }

// Float32Int64DictColumn represents a dict-encoded column with underlying data of type
// Float32 and dict key of type Int64
type Float32Int64DictColumn struct {
	refs *Int64Column
	pool *Float32Column
}

// Value constructs a value of type Float32 from the Float32Int64DictColumn
func (a *Float32Int64DictColumn) Value(i int) (float32, bool) {
	ref, isValid := a.refs.Value(i)
	var out float32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float32Int64DictColumn) Values() ([]float32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]float32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Float32Int64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Float32Int64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float32Int64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float32Int64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Float32Int64DictColumn) NullN() int64 { return a.refs.nNull }

// Float32Uint8DictColumn represents a dict-encoded column with underlying data of type
// Float32 and dict key of type Uint8
type Float32Uint8DictColumn struct {
	refs *Uint8Column
	pool *Float32Column
}

// Value constructs a value of type Float32 from the Float32Uint8DictColumn
func (a *Float32Uint8DictColumn) Value(i int) (float32, bool) {
	ref, isValid := a.refs.Value(i)
	var out float32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float32Uint8DictColumn) Values() ([]float32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]float32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Float32Uint8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Float32Uint8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float32Uint8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float32Uint8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Float32Uint8DictColumn) NullN() int64 { return a.refs.nNull }

// Float32Uint16DictColumn represents a dict-encoded column with underlying data of type
// Float32 and dict key of type Uint16
type Float32Uint16DictColumn struct {
	refs *Uint16Column
	pool *Float32Column
}

// Value constructs a value of type Float32 from the Float32Uint16DictColumn
func (a *Float32Uint16DictColumn) Value(i int) (float32, bool) {
	ref, isValid := a.refs.Value(i)
	var out float32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float32Uint16DictColumn) Values() ([]float32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]float32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Float32Uint16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Float32Uint16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float32Uint16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float32Uint16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Float32Uint16DictColumn) NullN() int64 { return a.refs.nNull }

// Float32Uint32DictColumn represents a dict-encoded column with underlying data of type
// Float32 and dict key of type Uint32
type Float32Uint32DictColumn struct {
	refs *Uint32Column
	pool *Float32Column
}

// Value constructs a value of type Float32 from the Float32Uint32DictColumn
func (a *Float32Uint32DictColumn) Value(i int) (float32, bool) {
	ref, isValid := a.refs.Value(i)
	var out float32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float32Uint32DictColumn) Values() ([]float32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]float32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Float32Uint32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Float32Uint32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float32Uint32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float32Uint32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Float32Uint32DictColumn) NullN() int64 { return a.refs.nNull }

// Float32Uint64DictColumn represents a dict-encoded column with underlying data of type
// Float32 and dict key of type Uint64
type Float32Uint64DictColumn struct {
	refs *Uint64Column
	pool *Float32Column
}

// Value constructs a value of type Float32 from the Float32Uint64DictColumn
func (a *Float32Uint64DictColumn) Value(i int) (float32, bool) {
	ref, isValid := a.refs.Value(i)
	var out float32
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float32Uint64DictColumn) Values() ([]float32, []bool) {
	refs, valids := a.refs.Values()
	out := make([]float32, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Float32Uint64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Float32Uint64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float32Uint64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float32Uint64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Float32Uint64DictColumn) NullN() int64 { return a.refs.nNull }

// Float64Int8DictColumn represents a dict-encoded column with underlying data of type
// Float64 and dict key of type Int8
type Float64Int8DictColumn struct {
	refs *Int8Column
	pool *Float64Column
}

// Value constructs a value of type Float64 from the Float64Int8DictColumn
func (a *Float64Int8DictColumn) Value(i int) (float64, bool) {
	ref, isValid := a.refs.Value(i)
	var out float64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float64Int8DictColumn) Values() ([]float64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]float64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Float64Int8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Float64Int8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float64Int8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float64Int8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Float64Int8DictColumn) NullN() int64 { return a.refs.nNull }

// Float64Int16DictColumn represents a dict-encoded column with underlying data of type
// Float64 and dict key of type Int16
type Float64Int16DictColumn struct {
	refs *Int16Column
	pool *Float64Column
}

// Value constructs a value of type Float64 from the Float64Int16DictColumn
func (a *Float64Int16DictColumn) Value(i int) (float64, bool) {
	ref, isValid := a.refs.Value(i)
	var out float64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float64Int16DictColumn) Values() ([]float64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]float64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Float64Int16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Float64Int16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float64Int16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float64Int16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Float64Int16DictColumn) NullN() int64 { return a.refs.nNull }

// Float64Int32DictColumn represents a dict-encoded column with underlying data of type
// Float64 and dict key of type Int32
type Float64Int32DictColumn struct {
	refs *Int32Column
	pool *Float64Column
}

// Value constructs a value of type Float64 from the Float64Int32DictColumn
func (a *Float64Int32DictColumn) Value(i int) (float64, bool) {
	ref, isValid := a.refs.Value(i)
	var out float64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float64Int32DictColumn) Values() ([]float64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]float64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Float64Int32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Float64Int32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float64Int32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float64Int32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Float64Int32DictColumn) NullN() int64 { return a.refs.nNull }

// Float64Int64DictColumn represents a dict-encoded column with underlying data of type
// Float64 and dict key of type Int64
type Float64Int64DictColumn struct {
	refs *Int64Column
	pool *Float64Column
}

// Value constructs a value of type Float64 from the Float64Int64DictColumn
func (a *Float64Int64DictColumn) Value(i int) (float64, bool) {
	ref, isValid := a.refs.Value(i)
	var out float64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float64Int64DictColumn) Values() ([]float64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]float64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Float64Int64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Float64Int64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float64Int64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float64Int64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Float64Int64DictColumn) NullN() int64 { return a.refs.nNull }

// Float64Uint8DictColumn represents a dict-encoded column with underlying data of type
// Float64 and dict key of type Uint8
type Float64Uint8DictColumn struct {
	refs *Uint8Column
	pool *Float64Column
}

// Value constructs a value of type Float64 from the Float64Uint8DictColumn
func (a *Float64Uint8DictColumn) Value(i int) (float64, bool) {
	ref, isValid := a.refs.Value(i)
	var out float64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float64Uint8DictColumn) Values() ([]float64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]float64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Float64Uint8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Float64Uint8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float64Uint8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float64Uint8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Float64Uint8DictColumn) NullN() int64 { return a.refs.nNull }

// Float64Uint16DictColumn represents a dict-encoded column with underlying data of type
// Float64 and dict key of type Uint16
type Float64Uint16DictColumn struct {
	refs *Uint16Column
	pool *Float64Column
}

// Value constructs a value of type Float64 from the Float64Uint16DictColumn
func (a *Float64Uint16DictColumn) Value(i int) (float64, bool) {
	ref, isValid := a.refs.Value(i)
	var out float64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float64Uint16DictColumn) Values() ([]float64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]float64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Float64Uint16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Float64Uint16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float64Uint16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float64Uint16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Float64Uint16DictColumn) NullN() int64 { return a.refs.nNull }

// Float64Uint32DictColumn represents a dict-encoded column with underlying data of type
// Float64 and dict key of type Uint32
type Float64Uint32DictColumn struct {
	refs *Uint32Column
	pool *Float64Column
}

// Value constructs a value of type Float64 from the Float64Uint32DictColumn
func (a *Float64Uint32DictColumn) Value(i int) (float64, bool) {
	ref, isValid := a.refs.Value(i)
	var out float64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float64Uint32DictColumn) Values() ([]float64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]float64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Float64Uint32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Float64Uint32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float64Uint32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float64Uint32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Float64Uint32DictColumn) NullN() int64 { return a.refs.nNull }

// Float64Uint64DictColumn represents a dict-encoded column with underlying data of type
// Float64 and dict key of type Uint64
type Float64Uint64DictColumn struct {
	refs *Uint64Column
	pool *Float64Column
}

// Value constructs a value of type Float64 from the Float64Uint64DictColumn
func (a *Float64Uint64DictColumn) Value(i int) (float64, bool) {
	ref, isValid := a.refs.Value(i)
	var out float64
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *Float64Uint64DictColumn) Values() ([]float64, []bool) {
	refs, valids := a.refs.Values()
	out := make([]float64, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *Float64Uint64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *Float64Uint64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *Float64Uint64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *Float64Uint64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *Float64Uint64DictColumn) NullN() int64 { return a.refs.nNull }

// StringInt8DictColumn represents a dict-encoded column with underlying data of type
// String and dict key of type Int8
type StringInt8DictColumn struct {
	refs *Int8Column
	pool *StringColumn
}

// Value constructs a value of type String from the StringInt8DictColumn
func (a *StringInt8DictColumn) Value(i int) (string, bool) {
	ref, isValid := a.refs.Value(i)
	var out string
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *StringInt8DictColumn) Values() ([]string, []bool) {
	refs, valids := a.refs.Values()
	out := make([]string, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *StringInt8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *StringInt8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *StringInt8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *StringInt8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *StringInt8DictColumn) NullN() int64 { return a.refs.nNull }

// StringInt16DictColumn represents a dict-encoded column with underlying data of type
// String and dict key of type Int16
type StringInt16DictColumn struct {
	refs *Int16Column
	pool *StringColumn
}

// Value constructs a value of type String from the StringInt16DictColumn
func (a *StringInt16DictColumn) Value(i int) (string, bool) {
	ref, isValid := a.refs.Value(i)
	var out string
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *StringInt16DictColumn) Values() ([]string, []bool) {
	refs, valids := a.refs.Values()
	out := make([]string, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *StringInt16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *StringInt16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *StringInt16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *StringInt16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *StringInt16DictColumn) NullN() int64 { return a.refs.nNull }

// StringInt32DictColumn represents a dict-encoded column with underlying data of type
// String and dict key of type Int32
type StringInt32DictColumn struct {
	refs *Int32Column
	pool *StringColumn
}

// Value constructs a value of type String from the StringInt32DictColumn
func (a *StringInt32DictColumn) Value(i int) (string, bool) {
	ref, isValid := a.refs.Value(i)
	var out string
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *StringInt32DictColumn) Values() ([]string, []bool) {
	refs, valids := a.refs.Values()
	out := make([]string, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *StringInt32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *StringInt32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *StringInt32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *StringInt32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *StringInt32DictColumn) NullN() int64 { return a.refs.nNull }

// StringInt64DictColumn represents a dict-encoded column with underlying data of type
// String and dict key of type Int64
type StringInt64DictColumn struct {
	refs *Int64Column
	pool *StringColumn
}

// Value constructs a value of type String from the StringInt64DictColumn
func (a *StringInt64DictColumn) Value(i int) (string, bool) {
	ref, isValid := a.refs.Value(i)
	var out string
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *StringInt64DictColumn) Values() ([]string, []bool) {
	refs, valids := a.refs.Values()
	out := make([]string, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *StringInt64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *StringInt64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *StringInt64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *StringInt64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *StringInt64DictColumn) NullN() int64 { return a.refs.nNull }

// StringUint8DictColumn represents a dict-encoded column with underlying data of type
// String and dict key of type Uint8
type StringUint8DictColumn struct {
	refs *Uint8Column
	pool *StringColumn
}

// Value constructs a value of type String from the StringUint8DictColumn
func (a *StringUint8DictColumn) Value(i int) (string, bool) {
	ref, isValid := a.refs.Value(i)
	var out string
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *StringUint8DictColumn) Values() ([]string, []bool) {
	refs, valids := a.refs.Values()
	out := make([]string, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *StringUint8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *StringUint8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *StringUint8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *StringUint8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *StringUint8DictColumn) NullN() int64 { return a.refs.nNull }

// StringUint16DictColumn represents a dict-encoded column with underlying data of type
// String and dict key of type Uint16
type StringUint16DictColumn struct {
	refs *Uint16Column
	pool *StringColumn
}

// Value constructs a value of type String from the StringUint16DictColumn
func (a *StringUint16DictColumn) Value(i int) (string, bool) {
	ref, isValid := a.refs.Value(i)
	var out string
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *StringUint16DictColumn) Values() ([]string, []bool) {
	refs, valids := a.refs.Values()
	out := make([]string, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *StringUint16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *StringUint16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *StringUint16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *StringUint16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *StringUint16DictColumn) NullN() int64 { return a.refs.nNull }

// StringUint32DictColumn represents a dict-encoded column with underlying data of type
// String and dict key of type Uint32
type StringUint32DictColumn struct {
	refs *Uint32Column
	pool *StringColumn
}

// Value constructs a value of type String from the StringUint32DictColumn
func (a *StringUint32DictColumn) Value(i int) (string, bool) {
	ref, isValid := a.refs.Value(i)
	var out string
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *StringUint32DictColumn) Values() ([]string, []bool) {
	refs, valids := a.refs.Values()
	out := make([]string, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *StringUint32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *StringUint32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *StringUint32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *StringUint32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *StringUint32DictColumn) NullN() int64 { return a.refs.nNull }

// StringUint64DictColumn represents a dict-encoded column with underlying data of type
// String and dict key of type Uint64
type StringUint64DictColumn struct {
	refs *Uint64Column
	pool *StringColumn
}

// Value constructs a value of type String from the StringUint64DictColumn
func (a *StringUint64DictColumn) Value(i int) (string, bool) {
	ref, isValid := a.refs.Value(i)
	var out string
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *StringUint64DictColumn) Values() ([]string, []bool) {
	refs, valids := a.refs.Values()
	out := make([]string, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *StringUint64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *StringUint64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *StringUint64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *StringUint64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *StringUint64DictColumn) NullN() int64 { return a.refs.nNull }

// BoolInt8DictColumn represents a dict-encoded column with underlying data of type
// Bool and dict key of type Int8
type BoolInt8DictColumn struct {
	refs *Int8Column
	pool *BoolColumn
}

// Value constructs a value of type Bool from the BoolInt8DictColumn
func (a *BoolInt8DictColumn) Value(i int) (bool, bool) {
	ref, isValid := a.refs.Value(i)
	var out bool
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *BoolInt8DictColumn) Values() ([]bool, []bool) {
	refs, valids := a.refs.Values()
	out := make([]bool, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *BoolInt8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *BoolInt8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *BoolInt8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *BoolInt8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *BoolInt8DictColumn) NullN() int64 { return a.refs.nNull }

// BoolInt16DictColumn represents a dict-encoded column with underlying data of type
// Bool and dict key of type Int16
type BoolInt16DictColumn struct {
	refs *Int16Column
	pool *BoolColumn
}

// Value constructs a value of type Bool from the BoolInt16DictColumn
func (a *BoolInt16DictColumn) Value(i int) (bool, bool) {
	ref, isValid := a.refs.Value(i)
	var out bool
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *BoolInt16DictColumn) Values() ([]bool, []bool) {
	refs, valids := a.refs.Values()
	out := make([]bool, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *BoolInt16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *BoolInt16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *BoolInt16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *BoolInt16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *BoolInt16DictColumn) NullN() int64 { return a.refs.nNull }

// BoolInt32DictColumn represents a dict-encoded column with underlying data of type
// Bool and dict key of type Int32
type BoolInt32DictColumn struct {
	refs *Int32Column
	pool *BoolColumn
}

// Value constructs a value of type Bool from the BoolInt32DictColumn
func (a *BoolInt32DictColumn) Value(i int) (bool, bool) {
	ref, isValid := a.refs.Value(i)
	var out bool
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *BoolInt32DictColumn) Values() ([]bool, []bool) {
	refs, valids := a.refs.Values()
	out := make([]bool, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *BoolInt32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *BoolInt32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *BoolInt32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *BoolInt32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *BoolInt32DictColumn) NullN() int64 { return a.refs.nNull }

// BoolInt64DictColumn represents a dict-encoded column with underlying data of type
// Bool and dict key of type Int64
type BoolInt64DictColumn struct {
	refs *Int64Column
	pool *BoolColumn
}

// Value constructs a value of type Bool from the BoolInt64DictColumn
func (a *BoolInt64DictColumn) Value(i int) (bool, bool) {
	ref, isValid := a.refs.Value(i)
	var out bool
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *BoolInt64DictColumn) Values() ([]bool, []bool) {
	refs, valids := a.refs.Values()
	out := make([]bool, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *BoolInt64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *BoolInt64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *BoolInt64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *BoolInt64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *BoolInt64DictColumn) NullN() int64 { return a.refs.nNull }

// BoolUint8DictColumn represents a dict-encoded column with underlying data of type
// Bool and dict key of type Uint8
type BoolUint8DictColumn struct {
	refs *Uint8Column
	pool *BoolColumn
}

// Value constructs a value of type Bool from the BoolUint8DictColumn
func (a *BoolUint8DictColumn) Value(i int) (bool, bool) {
	ref, isValid := a.refs.Value(i)
	var out bool
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *BoolUint8DictColumn) Values() ([]bool, []bool) {
	refs, valids := a.refs.Values()
	out := make([]bool, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *BoolUint8DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *BoolUint8DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *BoolUint8DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *BoolUint8DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *BoolUint8DictColumn) NullN() int64 { return a.refs.nNull }

// BoolUint16DictColumn represents a dict-encoded column with underlying data of type
// Bool and dict key of type Uint16
type BoolUint16DictColumn struct {
	refs *Uint16Column
	pool *BoolColumn
}

// Value constructs a value of type Bool from the BoolUint16DictColumn
func (a *BoolUint16DictColumn) Value(i int) (bool, bool) {
	ref, isValid := a.refs.Value(i)
	var out bool
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *BoolUint16DictColumn) Values() ([]bool, []bool) {
	refs, valids := a.refs.Values()
	out := make([]bool, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *BoolUint16DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *BoolUint16DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *BoolUint16DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *BoolUint16DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *BoolUint16DictColumn) NullN() int64 { return a.refs.nNull }

// BoolUint32DictColumn represents a dict-encoded column with underlying data of type
// Bool and dict key of type Uint32
type BoolUint32DictColumn struct {
	refs *Uint32Column
	pool *BoolColumn
}

// Value constructs a value of type Bool from the BoolUint32DictColumn
func (a *BoolUint32DictColumn) Value(i int) (bool, bool) {
	ref, isValid := a.refs.Value(i)
	var out bool
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *BoolUint32DictColumn) Values() ([]bool, []bool) {
	refs, valids := a.refs.Values()
	out := make([]bool, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *BoolUint32DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *BoolUint32DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *BoolUint32DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *BoolUint32DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *BoolUint32DictColumn) NullN() int64 { return a.refs.nNull }

// BoolUint64DictColumn represents a dict-encoded column with underlying data of type
// Bool and dict key of type Uint64
type BoolUint64DictColumn struct {
	refs *Uint64Column
	pool *BoolColumn
}

// Value constructs a value of type Bool from the BoolUint64DictColumn
func (a *BoolUint64DictColumn) Value(i int) (bool, bool) {
	ref, isValid := a.refs.Value(i)
	var out bool
	if isValid {
		out, _ = a.pool.Value(int(ref))
		return out, true
	}
	return out, false
}

// Values extracts slices of all values as well as a []bool indicating validity
// of all elements. If there are no null values, then the second slice will be
// nil. An entry of false in the second slice indicates that the corresponding
// value is null
func (a *BoolUint64DictColumn) Values() ([]bool, []bool) {
	refs, valids := a.refs.Values()
	out := make([]bool, len(refs))
	poolvals, _ := a.pool.Values()
	if valids != nil {
		for ix := 0; ix < len(refs); ix++ {
			if valids[ix] {
				out[ix] = poolvals[refs[ix]]
			}
		}
	} else {
		for ix := 0; ix < len(refs); ix++ {
			out[ix] = poolvals[refs[ix]]
		}
	}
	return out, valids
}

// Name returns the name of the column
func (a *BoolUint64DictColumn) Name() string { return a.refs.name }

// Length returns the number of rows in the column
func (a *BoolUint64DictColumn) Length() int { return int(a.refs.length) }

// Type returns an integer specifying the data typed contained by the column
func (a *BoolUint64DictColumn) Type() int8 { return a.pool.typE }

// TypeString returns a string describing the data typed contained by the column
func (a *BoolUint64DictColumn) TypeString() string { return fbs.EnumNamesTypE[int8(a.pool.typE)] }

// NullN returns how many null values there are in the column
func (a *BoolUint64DictColumn) NullN() int64 { return a.refs.nNull }

// DictColumn constructs a well-typed dict encoded column from the FeatherColumn
func DictColumn(refs, pool FeatherColumn) FeatherColumn {
	switch refs.Type() {

	case fbs.TypEINT8:
		switch pool.Type() {

		case fbs.TypEINT8:
			return &Int8Int8DictColumn{refs.(*Int8Column), pool.(*Int8Column)}
		case fbs.TypEINT16:
			return &Int16Int8DictColumn{refs.(*Int8Column), pool.(*Int16Column)}
		case fbs.TypEINT32:
			return &Int32Int8DictColumn{refs.(*Int8Column), pool.(*Int32Column)}
		case fbs.TypEINT64:
			return &Int64Int8DictColumn{refs.(*Int8Column), pool.(*Int64Column)}
		case fbs.TypEUINT8:
			return &Uint8Int8DictColumn{refs.(*Int8Column), pool.(*Uint8Column)}
		case fbs.TypEUINT16:
			return &Uint16Int8DictColumn{refs.(*Int8Column), pool.(*Uint16Column)}
		case fbs.TypEUINT32:
			return &Uint32Int8DictColumn{refs.(*Int8Column), pool.(*Uint32Column)}
		case fbs.TypEUINT64:
			return &Uint64Int8DictColumn{refs.(*Int8Column), pool.(*Uint64Column)}
		case fbs.TypEFLOAT:
			return &Float32Int8DictColumn{refs.(*Int8Column), pool.(*Float32Column)}
		case fbs.TypEDOUBLE:
			return &Float64Int8DictColumn{refs.(*Int8Column), pool.(*Float64Column)}
		case fbs.TypEUTF8:
			return &StringInt8DictColumn{refs.(*Int8Column), pool.(*StringColumn)}
		case fbs.TypEBOOL:
			return &BoolInt8DictColumn{refs.(*Int8Column), pool.(*BoolColumn)}
		}

	case fbs.TypEINT16:
		switch pool.Type() {

		case fbs.TypEINT8:
			return &Int8Int16DictColumn{refs.(*Int16Column), pool.(*Int8Column)}
		case fbs.TypEINT16:
			return &Int16Int16DictColumn{refs.(*Int16Column), pool.(*Int16Column)}
		case fbs.TypEINT32:
			return &Int32Int16DictColumn{refs.(*Int16Column), pool.(*Int32Column)}
		case fbs.TypEINT64:
			return &Int64Int16DictColumn{refs.(*Int16Column), pool.(*Int64Column)}
		case fbs.TypEUINT8:
			return &Uint8Int16DictColumn{refs.(*Int16Column), pool.(*Uint8Column)}
		case fbs.TypEUINT16:
			return &Uint16Int16DictColumn{refs.(*Int16Column), pool.(*Uint16Column)}
		case fbs.TypEUINT32:
			return &Uint32Int16DictColumn{refs.(*Int16Column), pool.(*Uint32Column)}
		case fbs.TypEUINT64:
			return &Uint64Int16DictColumn{refs.(*Int16Column), pool.(*Uint64Column)}
		case fbs.TypEFLOAT:
			return &Float32Int16DictColumn{refs.(*Int16Column), pool.(*Float32Column)}
		case fbs.TypEDOUBLE:
			return &Float64Int16DictColumn{refs.(*Int16Column), pool.(*Float64Column)}
		case fbs.TypEUTF8:
			return &StringInt16DictColumn{refs.(*Int16Column), pool.(*StringColumn)}
		case fbs.TypEBOOL:
			return &BoolInt16DictColumn{refs.(*Int16Column), pool.(*BoolColumn)}
		}

	case fbs.TypEINT32:
		switch pool.Type() {

		case fbs.TypEINT8:
			return &Int8Int32DictColumn{refs.(*Int32Column), pool.(*Int8Column)}
		case fbs.TypEINT16:
			return &Int16Int32DictColumn{refs.(*Int32Column), pool.(*Int16Column)}
		case fbs.TypEINT32:
			return &Int32Int32DictColumn{refs.(*Int32Column), pool.(*Int32Column)}
		case fbs.TypEINT64:
			return &Int64Int32DictColumn{refs.(*Int32Column), pool.(*Int64Column)}
		case fbs.TypEUINT8:
			return &Uint8Int32DictColumn{refs.(*Int32Column), pool.(*Uint8Column)}
		case fbs.TypEUINT16:
			return &Uint16Int32DictColumn{refs.(*Int32Column), pool.(*Uint16Column)}
		case fbs.TypEUINT32:
			return &Uint32Int32DictColumn{refs.(*Int32Column), pool.(*Uint32Column)}
		case fbs.TypEUINT64:
			return &Uint64Int32DictColumn{refs.(*Int32Column), pool.(*Uint64Column)}
		case fbs.TypEFLOAT:
			return &Float32Int32DictColumn{refs.(*Int32Column), pool.(*Float32Column)}
		case fbs.TypEDOUBLE:
			return &Float64Int32DictColumn{refs.(*Int32Column), pool.(*Float64Column)}
		case fbs.TypEUTF8:
			return &StringInt32DictColumn{refs.(*Int32Column), pool.(*StringColumn)}
		case fbs.TypEBOOL:
			return &BoolInt32DictColumn{refs.(*Int32Column), pool.(*BoolColumn)}
		}

	case fbs.TypEINT64:
		switch pool.Type() {

		case fbs.TypEINT8:
			return &Int8Int64DictColumn{refs.(*Int64Column), pool.(*Int8Column)}
		case fbs.TypEINT16:
			return &Int16Int64DictColumn{refs.(*Int64Column), pool.(*Int16Column)}
		case fbs.TypEINT32:
			return &Int32Int64DictColumn{refs.(*Int64Column), pool.(*Int32Column)}
		case fbs.TypEINT64:
			return &Int64Int64DictColumn{refs.(*Int64Column), pool.(*Int64Column)}
		case fbs.TypEUINT8:
			return &Uint8Int64DictColumn{refs.(*Int64Column), pool.(*Uint8Column)}
		case fbs.TypEUINT16:
			return &Uint16Int64DictColumn{refs.(*Int64Column), pool.(*Uint16Column)}
		case fbs.TypEUINT32:
			return &Uint32Int64DictColumn{refs.(*Int64Column), pool.(*Uint32Column)}
		case fbs.TypEUINT64:
			return &Uint64Int64DictColumn{refs.(*Int64Column), pool.(*Uint64Column)}
		case fbs.TypEFLOAT:
			return &Float32Int64DictColumn{refs.(*Int64Column), pool.(*Float32Column)}
		case fbs.TypEDOUBLE:
			return &Float64Int64DictColumn{refs.(*Int64Column), pool.(*Float64Column)}
		case fbs.TypEUTF8:
			return &StringInt64DictColumn{refs.(*Int64Column), pool.(*StringColumn)}
		case fbs.TypEBOOL:
			return &BoolInt64DictColumn{refs.(*Int64Column), pool.(*BoolColumn)}
		}

	case fbs.TypEUINT8:
		switch pool.Type() {

		case fbs.TypEINT8:
			return &Int8Uint8DictColumn{refs.(*Uint8Column), pool.(*Int8Column)}
		case fbs.TypEINT16:
			return &Int16Uint8DictColumn{refs.(*Uint8Column), pool.(*Int16Column)}
		case fbs.TypEINT32:
			return &Int32Uint8DictColumn{refs.(*Uint8Column), pool.(*Int32Column)}
		case fbs.TypEINT64:
			return &Int64Uint8DictColumn{refs.(*Uint8Column), pool.(*Int64Column)}
		case fbs.TypEUINT8:
			return &Uint8Uint8DictColumn{refs.(*Uint8Column), pool.(*Uint8Column)}
		case fbs.TypEUINT16:
			return &Uint16Uint8DictColumn{refs.(*Uint8Column), pool.(*Uint16Column)}
		case fbs.TypEUINT32:
			return &Uint32Uint8DictColumn{refs.(*Uint8Column), pool.(*Uint32Column)}
		case fbs.TypEUINT64:
			return &Uint64Uint8DictColumn{refs.(*Uint8Column), pool.(*Uint64Column)}
		case fbs.TypEFLOAT:
			return &Float32Uint8DictColumn{refs.(*Uint8Column), pool.(*Float32Column)}
		case fbs.TypEDOUBLE:
			return &Float64Uint8DictColumn{refs.(*Uint8Column), pool.(*Float64Column)}
		case fbs.TypEUTF8:
			return &StringUint8DictColumn{refs.(*Uint8Column), pool.(*StringColumn)}
		case fbs.TypEBOOL:
			return &BoolUint8DictColumn{refs.(*Uint8Column), pool.(*BoolColumn)}
		}

	case fbs.TypEUINT16:
		switch pool.Type() {

		case fbs.TypEINT8:
			return &Int8Uint16DictColumn{refs.(*Uint16Column), pool.(*Int8Column)}
		case fbs.TypEINT16:
			return &Int16Uint16DictColumn{refs.(*Uint16Column), pool.(*Int16Column)}
		case fbs.TypEINT32:
			return &Int32Uint16DictColumn{refs.(*Uint16Column), pool.(*Int32Column)}
		case fbs.TypEINT64:
			return &Int64Uint16DictColumn{refs.(*Uint16Column), pool.(*Int64Column)}
		case fbs.TypEUINT8:
			return &Uint8Uint16DictColumn{refs.(*Uint16Column), pool.(*Uint8Column)}
		case fbs.TypEUINT16:
			return &Uint16Uint16DictColumn{refs.(*Uint16Column), pool.(*Uint16Column)}
		case fbs.TypEUINT32:
			return &Uint32Uint16DictColumn{refs.(*Uint16Column), pool.(*Uint32Column)}
		case fbs.TypEUINT64:
			return &Uint64Uint16DictColumn{refs.(*Uint16Column), pool.(*Uint64Column)}
		case fbs.TypEFLOAT:
			return &Float32Uint16DictColumn{refs.(*Uint16Column), pool.(*Float32Column)}
		case fbs.TypEDOUBLE:
			return &Float64Uint16DictColumn{refs.(*Uint16Column), pool.(*Float64Column)}
		case fbs.TypEUTF8:
			return &StringUint16DictColumn{refs.(*Uint16Column), pool.(*StringColumn)}
		case fbs.TypEBOOL:
			return &BoolUint16DictColumn{refs.(*Uint16Column), pool.(*BoolColumn)}
		}

	case fbs.TypEUINT32:
		switch pool.Type() {

		case fbs.TypEINT8:
			return &Int8Uint32DictColumn{refs.(*Uint32Column), pool.(*Int8Column)}
		case fbs.TypEINT16:
			return &Int16Uint32DictColumn{refs.(*Uint32Column), pool.(*Int16Column)}
		case fbs.TypEINT32:
			return &Int32Uint32DictColumn{refs.(*Uint32Column), pool.(*Int32Column)}
		case fbs.TypEINT64:
			return &Int64Uint32DictColumn{refs.(*Uint32Column), pool.(*Int64Column)}
		case fbs.TypEUINT8:
			return &Uint8Uint32DictColumn{refs.(*Uint32Column), pool.(*Uint8Column)}
		case fbs.TypEUINT16:
			return &Uint16Uint32DictColumn{refs.(*Uint32Column), pool.(*Uint16Column)}
		case fbs.TypEUINT32:
			return &Uint32Uint32DictColumn{refs.(*Uint32Column), pool.(*Uint32Column)}
		case fbs.TypEUINT64:
			return &Uint64Uint32DictColumn{refs.(*Uint32Column), pool.(*Uint64Column)}
		case fbs.TypEFLOAT:
			return &Float32Uint32DictColumn{refs.(*Uint32Column), pool.(*Float32Column)}
		case fbs.TypEDOUBLE:
			return &Float64Uint32DictColumn{refs.(*Uint32Column), pool.(*Float64Column)}
		case fbs.TypEUTF8:
			return &StringUint32DictColumn{refs.(*Uint32Column), pool.(*StringColumn)}
		case fbs.TypEBOOL:
			return &BoolUint32DictColumn{refs.(*Uint32Column), pool.(*BoolColumn)}
		}

	case fbs.TypEUINT64:
		switch pool.Type() {

		case fbs.TypEINT8:
			return &Int8Uint64DictColumn{refs.(*Uint64Column), pool.(*Int8Column)}
		case fbs.TypEINT16:
			return &Int16Uint64DictColumn{refs.(*Uint64Column), pool.(*Int16Column)}
		case fbs.TypEINT32:
			return &Int32Uint64DictColumn{refs.(*Uint64Column), pool.(*Int32Column)}
		case fbs.TypEINT64:
			return &Int64Uint64DictColumn{refs.(*Uint64Column), pool.(*Int64Column)}
		case fbs.TypEUINT8:
			return &Uint8Uint64DictColumn{refs.(*Uint64Column), pool.(*Uint8Column)}
		case fbs.TypEUINT16:
			return &Uint16Uint64DictColumn{refs.(*Uint64Column), pool.(*Uint16Column)}
		case fbs.TypEUINT32:
			return &Uint32Uint64DictColumn{refs.(*Uint64Column), pool.(*Uint32Column)}
		case fbs.TypEUINT64:
			return &Uint64Uint64DictColumn{refs.(*Uint64Column), pool.(*Uint64Column)}
		case fbs.TypEFLOAT:
			return &Float32Uint64DictColumn{refs.(*Uint64Column), pool.(*Float32Column)}
		case fbs.TypEDOUBLE:
			return &Float64Uint64DictColumn{refs.(*Uint64Column), pool.(*Float64Column)}
		case fbs.TypEUTF8:
			return &StringUint64DictColumn{refs.(*Uint64Column), pool.(*StringColumn)}
		case fbs.TypEBOOL:
			return &BoolUint64DictColumn{refs.(*Uint64Column), pool.(*BoolColumn)}
		}

	case fbs.TypECATEGORY:
		fmt.Println("Have TypECATEGORY")
		return nil
	case fbs.TypETIMESTAMP:
		fmt.Println("Have TypETIMESTAMP")
		return nil
	case fbs.TypEDATE:
		fmt.Println("Have TypEDATE")
		return nil
	case fbs.TypETIME:
		fmt.Println("Have TypETIME")
		return nil
	default:
		fmt.Println("No ideas what I just saw...")
		return nil
	}
	return nil
}
